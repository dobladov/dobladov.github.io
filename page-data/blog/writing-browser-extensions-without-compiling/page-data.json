{"componentChunkName":"component---src-components-posts-js","path":"/blog/writing-browser-extensions-without-compiling/","result":{"data":{"site":{"siteMetadata":{"repositoryUrl":"https://github.com/dobladov/mdx-blog/edit/master/"}},"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Writing browser extensions without compiling\",\n  \"tags\": [\"js\", \"extension\", \"tooling\", \"framewor\"],\n  \"hook\": \"Positive changes for one of my extensions with the goal of making better extensions.\",\n  \"date\": \"2021-06-24\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", {\n    \"id\": \"complexity-is-the-enemy\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#complexity-is-the-enemy\",\n    \"aria-label\": \"complexity is the enemy permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Complexity is the enemy\"), mdx(\"p\", null, \"Recently one of my most popular \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/dobladov/youtube2Anki\"\n  }, \"extensions\"), \" received a full refactor, previously it was made with just pure JavaScript, this was fine since at the beginning it was a proof of concept, it means no complex bundles, frameworks, compilers, \\u2026\"), mdx(\"p\", null, \"But with complexity comes necessity, managing the state of the connection between the extension and Anki and editing the sentences got complicated using imperative logic; It\\u2019s amazing how used I became to declarative logic with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://reactjs.org/\"\n  }, \"React\"), \" and this is something that I was missing for this extension.\"), mdx(\"p\", null, \"I could use React, the problem is that if the extension needs to be compiled, the review in the extensions stores will be more exhaustive, taking more time and making longer to fix simple stuff like bugs.\"), mdx(\"p\", null, \"So in order to give trust and avoid wasting time in reviews, all the code needed to stay just as it was written.\"), mdx(\"p\", null, \"Tools like \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.snowpack.dev/\"\n  }, \"snowpack\"), \" made me realize that with the advance of JavaScript modules we might not need to compile what it\\u2019s an interpreted language, like seriously how did we reach this point.\"), mdx(\"h3\", {\n    \"id\": \"coming-with-simpler-solutions\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#coming-with-simpler-solutions\",\n    \"aria-label\": \"coming with simpler solutions permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Coming with simpler solutions\"), mdx(\"p\", null, \"Let\\u2019s look at the requirements, I wanted to use components, separate my logic from styles, use declarative logic, not set up any bundler (webpack, parcel, etc\\u2026) for this React would not make the cut since JSX needs some tooling and care.\"), mdx(\"p\", null, \"So the decision went to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://skruv.io/\"\n  }, \"Skruv\"), \", this framework is amazing, not only is tiny, modular and simple to learn, the docs are amazing well organized and clear, covering all functionality without extras.\"), mdx(\"p\", null, \"You can tell how nice the framework is by looking at this framework\\u2019s goals:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"No build time or runtime dependencies, no parsers\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Pretty small:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"~350 LOC vDOM\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"~100 LOC State management\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"~300 LOC HTML/SVG helpers\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Useable without bundling/compilation/transpilation\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Fast enough for most normal use cases: benchmark\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Supports async components like import() and async generators\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"CSS scoping via shadow DOM\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Hopefully grokable/understandable code\")), mdx(\"p\", null, \"The best part is that to use it I just have to import the files, that\\u2019s it.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"hljs language-javascript\"\n  }, mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"hljs-keyword\"\n  }, \"import\"), \" { div } \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"hljs-keyword\"\n  }, \"from\"), \"  \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"hljs-string\"\n  }, \"'./skruv/html.js'\"), \"\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"hljs-keyword\"\n  }, \"import\"), \" { renderNode } \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"hljs-keyword\"\n  }, \"from\"), \"  \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"hljs-string\"\n  }, \"'./skruv/vDOM.js'\"), \"\\n\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"hljs-keyword\"\n  }, \"let\"), \" root = \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"hljs-built_in\"\n  }, \"document\"), \".querySelector(\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"hljs-string\"\n  }, \"'#root'\"), \")\\n\\nroot =  renderNode(\\n\\tdiv({}, \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"hljs-string\"\n  }, \"'Hello world!'\"), \"),\\n\\troot\\n)\")), mdx(\"p\", null, \"On top of those advantages, I love the nested syntax, far shorter than JSX, now that I think about it feels weird that we moved to write HTML in JS.\"), mdx(\"p\", null, \"You might be also wondering, \\u201Cwhat if I need typescript, do you have to transpile?\\u201D the answer is no, you can use \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html\"\n  }, \"JSDocs with Typescript\"), \" without having to create a single \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ts\"), \" file.\"), mdx(\"h3\", {\n    \"id\": \"how-it-ended\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#how-it-ended\",\n    \"aria-label\": \"how it ended permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"How it ended\"), mdx(\"p\", null, \"I feel this change was a success, new code can be iterated easily without having to worry much about state or building, since the extension runs on modern browsers I don\\u2019t have to care about with babel, etc\"), mdx(\"p\", null, \"Right now the only concern I have about the extension is manifest v3 which is not supported in Firefox yet, but this is a story for another post.\"), mdx(\"p\", null, \"I have to say that I\\u2019m glad about the feedback people gave, this refactor was motivated because changes on Youtube made it fail and people reported issues with a lot of support, not only that, but I\\u2019ve seen articles written in Vietnamese, Japanese and German in how to use the extension and how they find it useful, it really makes want to keep contributing free, anti-traking open-source code.\"));\n}\n;\nMDXContent.isMDXComponent = true;","fileAbsolutePath":"/home/runner/work/mdx-blog/mdx-blog/content/blog/writing-browser-extensions-without-compiling.mdx","fields":{"slug":"/blog/writing-browser-extensions-without-compiling/","date":"2021-06-24"},"frontmatter":{"title":"Writing browser extensions without compiling","tags":["js","extension","tooling","framewor"],"hook":"Positive changes for one of my extensions with the goal of making better extensions.","featuredImage":null},"excerpt":"Complexity is the enemy Recently one of my most popular  extensions  received a full refactor, previously it was made with just pure…","tableOfContents":{"items":[{"url":"#complexity-is-the-enemy","title":"Complexity is the enemy","items":[{"url":"#coming-with-simpler-solutions","title":"Coming with simpler solutions"},{"url":"#how-it-ended","title":"How it ended"}]}]},"timeToRead":2}},"pageContext":{"id":"35e74120-cd2e-52ac-ab31-d6c766407aa1"}},"staticQueryHashes":["3649515864","63159454"]}